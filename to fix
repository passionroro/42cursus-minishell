QUOTES:
> echo $HOME
/Users/rohoarau
> echo "$HOME"
/Users/rohoarau
> echo '$HOME'
$HOME
> echo '$HO'ME
$HOME
> echo "$HO"ME
ME
> unset HOME
> echo $HOME

> echo "'"
'
> echo "'""'"
''
> echo """
Please close the quotes
> echo "\"\\"
"\

TODO:
stop using ft_putstr_fd!!!
function that counts the number of single quotes and double quotes
function that give their position (to determine wether the quote is inside or not)
we don't want to run dollar_sign_check when the string is inside single quotes (echo '$HOME')
idea : whenever we encounter a dollar, we check if the string attached to the dollar sign exists in the env (echo $PATH). if it's in a double quote, we check until the closing double quote (echo "$P"ATH should check if $P exists. if not, remove $P and the quotes). if it's inside a single quote, don't run the replacing algo (echo '$HOME' only removes the quotes)
don't forger to add $? in the dollar_sign_check


echo -n salut > txt 
--> doesn't redirect

for the return value, it might be possible that exit.c changes the return value that was assigned manualy (for example g_ret = 127 might be overwrite by the g_ret = WEXITSTATUS(wstatus))

yossi : 

norminette OK ! redirections OK !

1. leaks everywhere. every command we type. even ls 

2. to send all the error messages in the program to the stderr(2).
there's a function called write_error in utils_built_in.c that takes 4 parameters:
the first 3 are strings to print in stderr, and the 4th is the int the fuction returns.

the fuction always frees the 2nd string sent to it so if you want to print 2 strings without freeing any you send like this : write_error(str1, NULL, str2, ret_int)

there's no other way to do it if we dont want leaks, I can explain why

kings in the castle :R
